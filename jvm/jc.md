# JAVA垃圾回收机制

## 如何判断一个对象是否已经死去？
* 引用计数法，只要有一个地方引用它，计数器就加1，引用失效的话计数器减1。这样有一个坑爹的地方就是相互循环引用的问题
* 可达性分析：以“GC Roots”的对象作为起始点，从这些节点向下搜索，所走过的路径成为引用链（Reference Chain），当一个对象到GC Roots 没有任何引用连，则该对象不可达，可回收。

## 可作为GC Roots的对象包括哪些？
* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI（java native interface）引用的对象

## 引用的分类：
* 强引用：通过new出来的引用，只要强引用还存在，则不会回收。
* 软引用：通过SoftReference类来实现，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象回收了，如果这次回收还是内存不够的话，才抛出内存溢出异常。
* 弱引用：非必须对象，通过WeakReference类来实现，被弱引用引用的对象，只要已发生GC就会把它干掉。
* 虚引用：通过PhantomReference类来实现，无法通过徐引用获得对象的实例，唯一作用就是在这个对象被GC时会收到一个系统通知。
## 回收方法区(永久代)： 来存储class类、常量、方法描述
* 回收废弃常量，就是没有任何实例叫做这个常量
* 回收无用类，1.所有实例都被回收 2.加载该类的ClassLoader也被回收 3.该类对应的java.lang.Class对象没有任何地方引用，无法在任何地方通过反射访问该类的方法。满足以上三个条件才回收该类

## 垃圾回收算法
垃圾回收算法主要有一下四种：标记-清除（Mark-Sweep），复制算法（copying），标记-整理（Mark-Compact），分代收集算法  
### 标记-清除算法
* 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
* 缺点：1.效率问题，标记和清除两个过程效率都不高 2.空间问题，标记清除后会有大量的内存碎片

### 复制算法
* 它将内存容量划分为大小相等两块，每次只使用其中的一块。当一块内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。
* 现在商业虚拟机都采用这种手机算法来回收新生代，但斌不是1:1的比例来分配内存，而是一块较大的Eden空间，和两块较小的Survivor空间，每次使用Eden和其中一块Survior。当回收时，将还存活的对象复制到另一块Survivor空间上，然后清理这两块空间，这过程中，当Survior空间不足时，回想老年代分配担保。HotSpot虚拟机采用的是8:1:1的比例。也就是浪费了10%的内存。
### 标记-整理算法
* 根据老年代的特点，有人提出了标记-整理算法，也是先标记出所有需要回收的对象，但后续步骤不是对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
* 它一般在老年代采用这种方法。

## 分代收集算法
* 分代收集算法并没有提出新的思想，只是根据对象存活周期的不同将内存划为几块。一般Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。
* 在新生袋中每次垃圾手机时都会由大批对象死去，只有少量存活，那就用复制算法，只需要付出少量存活对象的复制成本就可以。老年代中对象存活率高、没有额外担保，所以必须使用“标记-清理”或者“标记整理算法。

## 垃圾收集器
垃圾收集算法是 内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。下面介绍一下HotSpot（JDK 7)虚拟机提供的几种垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。
### Serial/Serial Old
Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。

### ParNew
ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。除了serial外，只有ParNew能跟CMS配合工作。因此，采用CMS作为老年代收集器的话，那么新生代你就只能选择ParNew和Serial，而不能选择比较新的Parallel Scavenge

### Parallel Scavenge
Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。

### Parallel Old
Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。

### CMS
CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。

### G1
G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。

## Minor GC 与Major GC/Full GC

* Minor GC：指发生在新生代的垃圾收集动作，因为java对象大多具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快，当Eden去满了的时候就会发生Minor GC。
* Full GC：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavange收集器的手机策略中就有直接进行Major GC的策略选择过程）。Major GC的速度一般比Minor GC慢10倍以上。

对象分配规则  
1. 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。  
2. 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。  
3. 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
4. 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
5. 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Minor GC,如果false则进行Full GC。
